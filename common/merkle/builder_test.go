package merkle_test

import (
	"bytes"
	"encoding/hex"
	"fmt"
	"testing"

	"github.com/icon-project/goloop/common/crypto"
	"github.com/icon-project/goloop/common/db"
	"github.com/icon-project/goloop/common/merkle"
)

const TestHasher db.BucketID = "T"

type testHasher struct {
}

func (h testHasher) Name() string {
	return "testhash"
}

func (h testHasher) Hash(v []byte) []byte {
	// return same hash as SHA3Sum
	return crypto.SHA3Sum256([]byte("0x123"))
}

func init() {
	db.RegisterHasher(TestHasher, testHasher{})
}

type requestor struct {
	id db.BucketID
}

func (req requestor) OnData(v []byte, builder merkle.Builder) error {
	fmt.Printf("bucket id : %v, value : %x\n", req.id, v)
	return nil
}

func TestMerkleBuilderSameKey(t *testing.T) {

	mapdb := db.NewMapDB()
	builder := merkle.NewBuilder(mapdb)

	// given same key generated by sha3 and testhash
	value1 := []byte("0x123")
	key1 := crypto.SHA3Sum256(value1)
	req1 := &requestor{
		id: db.BytesByHash,
	}

	value2 := []byte("0xabc")
	key2 := key1[:]
	req2 := &requestor{
		id: TestHasher,
	}

	// when make merkle builer
	builder.RequestData(db.BytesByHash, key1, req1)
	builder.RequestData(TestHasher, key2, req2)

	reqiter := builder.Requests()
	for reqiter.Next() {
		key := reqiter.Key()
		for _, bid := range reqiter.BucketIDs() {
			if bid.Hasher().Name() == "sha3" {
				fmt.Println("sha3 key :", hex.EncodeToString(key))
				builder.OnData(db.BytesByHash, value1)
			} else if bid.Hasher().Name() == "testhash" {
				fmt.Println("testhash key :", hex.EncodeToString(key))
				builder.OnData(TestHasher, value2)
			}
		}
	}

	builder.Flush(true)

	// then store to db without conflict
	bk1, _ := mapdb.GetBucket(db.BytesByHash)
	actual1, _ := bk1.Get(key1)
	if !bytes.Equal(actual1, value1) {
		t.Errorf("Not equal! expect=%x, actual=%x", value1, actual1)
	}

	bk2, _ := mapdb.GetBucket(TestHasher)
	actual2, _ := bk2.Get(key2)
	if !bytes.Equal(actual2, value2) {
		t.Errorf("Not equal! expect=%x, actual=%x", value2, actual2)
	}
}
